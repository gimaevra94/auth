logout.go
package auth

import (
	"net/http"

	"github.com/gimaevra94/auth/app/consts"
	"github.com/gimaevra94/auth/app/data"
	"github.com/gimaevra94/auth/app/tools"
)

func Logout(w http.ResponseWriter, r *http.Request) {
	Revocate(w, r, true, true, true)
	http.Redirect(w, r, consts.SignInURL, http.StatusFound)
}

func SimpleLogout(w http.ResponseWriter, r *http.Request) {
	Revocate(w, r, true, true, false)
	http.Redirect(w, r, consts.SignInURL, http.StatusFound)
}

func Revocate(w http.ResponseWriter, r *http.Request, CookiesClear, temporaryIdCancel, refreshTokenCancel bool) {
	if CookiesClear {
		data.ClearTemporaryIdInCookies(w)
	}

	tx, err := data.Db.Begin()
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	defer func() {
		if err := recover(); err != nil {
			tx.Rollback()
			panic(err)
		}
	}()

	Cookies, err := data.GetTemporaryIdFromCookies(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
	temporaryId := Cookies.Value

	if temporaryIdCancel {
		if err := data.SetTemporaryIdCancelledInDbTx(tx, temporaryId); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
	}

	if refreshTokenCancel {
		_, _, permanentId, _, err := data.GetAllUserKeysFromDb(temporaryId)
		if err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}

		refreshToken, userAgent, refreshTokenCancelled, err := data.GetAllRefreshTokenKeysFromDb(permanentId, r.UserAgent())
		if err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}

		if !refreshTokenCancelled {
			if err := data.SetRefreshTokenCancelledInDbTx(tx, refreshToken, userAgent); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
		}
	}

	if err := tx.Commit(); err != nil {
		tx.Rollback()
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

passwordResetter.go
package auth

import (
	"database/sql"
	"net/http"
	"net/url"

	"github.com/gimaevra94/auth/app/consts"
	"github.com/gimaevra94/auth/app/data"
	"github.com/gimaevra94/auth/app/structs"
	"github.com/gimaevra94/auth/app/tools"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"golang.org/x/crypto/bcrypt"
)

func GeneratePasswordResetLink(w http.ResponseWriter, r *http.Request) {
	email := r.FormValue("email")
	if err := tools.EmailValidate(email); err != nil {
		data := structs.MsgForUser{Msg: consts.MsgForUser["invalidEmail"].Msg, Regs: nil}
		if err := tools.TmplsRenderer(w, tools.BaseTmpl, "PasswordReset", data); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
	}

	if _, err := data.GetPermanentIdFromDb(email); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			data := structs.MsgForUser{Msg: consts.MsgForUser["userNotExist"].Msg, Regs: nil}
			if err := tools.TmplsRenderer(w, tools.BaseTmpl, "PasswordReset", data); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
			return
		}
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	baseURL := "http://localhost:8080/set-new-password"
	passwordResetLink, err := tools.GeneratePasswordResetLink(email, baseURL)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	url, err := url.Parse(passwordResetLink)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	resetToken := url.Query().Get("token")
	if resetToken != "" {
		tx, err := data.Db.Begin()
		if err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}

		defer func() {
			if err := recover(); err != nil {
				tx.Rollback()
				panic(err)
			}
		}()

		if err := data.SetPasswordResetTokenInDbTx(tx, resetToken); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}

		if err := tx.Commit(); err != nil {
			tx.Rollback()
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
	}

	if err := tools.PasswordResetEmailSend(email, passwordResetLink); err != nil {
		data := structs.MsgForUser{Msg: consts.MsgForUser["failedMailSendingStatus"].Msg, Regs: nil}
		if err := tools.TmplsRenderer(w, tools.BaseTmpl, "PasswordReset", data); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
		return
	}

	if r.Method == http.MethodPost {
		data := structs.MsgForUser{Msg: consts.MsgForUser["successfulMailSendingStatus"].Msg, Regs: nil}
		if err := tools.TmplsRenderer(w, tools.BaseTmpl, "PasswordReset", data); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
		return
	}
}

func SetNewPassword(w http.ResponseWriter, r *http.Request) {
	resetToken := r.FormValue("token")
	if resetToken == "" {
		err := errors.New("reset-token not exist")
		wrappederr := errors.WithStack(err)
		tools.LogAndRedirectIfErrNotNill(w, r, wrappederr, consts.Err500URL)
		return
	}

	claims, err := tools.ResetTokenValidate(resetToken)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	cancelled, err := data.GetResetTokenCancelledFromDb(resetToken)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if cancelled {
		err := errors.New("reset-token invalid")
		wrappederr := errors.WithStack(err)
		tools.LogAndRedirectIfErrNotNill(w, r, wrappederr, consts.Err500URL)
		return
	}

	newPassword := r.FormValue("newPassword")
	confirmPassword := r.FormValue("confirmPassword")

	if newPassword != confirmPassword {
		data := structs.MsgForUser{Msg: consts.MsgForUser["passwordsNotMatch"].Msg, Regs: nil}
		if err := tools.TmplsRenderer(w, tools.BaseTmpl, "SetNewPassword", data); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
		return
	}

	if err := tools.PasswordValidate(newPassword); err != nil {
		data := structs.MsgForUser{Msg: consts.MsgForUser["invalidPassword"].Msg, Regs: nil}
		if err := tools.TmplsRenderer(w, tools.BaseTmpl, "SetNewPassword", data); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
		return
	}

	permanentId, err := data.GetPermanentIdFromDb(claims.Email)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	tx, err := data.Db.Begin()
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	defer func() {
		if err := recover(); err != nil {
			tx.Rollback()
			panic(err)
		}
	}()

	if err := data.SetPasswordInDbByEmailTx(tx, claims.Email, newPassword); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err := data.SetPasswordResetTokenCancelledInDbTx(tx, resetToken); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	temporaryId := uuid.New().String()
	temporaryIdCancelled := false
	if err := data.SetTemporaryIdInDbByEmailTx(tx, claims.Email, temporaryId, temporaryIdCancelled); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	rememberMe := false
	refreshToken, err := tools.GeneraterefreshToken(consts.RefreshTokenExp7Days, rememberMe)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	refreshTokenCancelled := false
	if err := data.SetRefreshTokenInDbTx(tx, permanentId, refreshToken, r.UserAgent(), refreshTokenCancelled); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err := tx.Commit(); err != nil {
		tx.Rollback()
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	data.SetTemporaryIdInCookies(w, temporaryId)
	http.Redirect(w, r, consts.HomeURL, http.StatusFound)
}

func SetFirstTimePassword(w http.ResponseWriter, r *http.Request) {
	cookies, err := data.GetTemporaryIdFromCookies(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	temporaryId := cookies.Value
	passwordHash, err := data.GetPasswordFromDb(temporaryId)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if passwordHash != "" {
		err := errors.New("password already set")
		wrappedErr := errors.WithStack(err)
		tools.LogAndRedirectIfErrNotNill(w, r, wrappedErr, consts.Err500URL)
		return
	}

	password := r.FormValue("password")
	confirmPassword := r.FormValue("confirmPassword")

	if password != confirmPassword {
		data := structs.MsgForUser{Msg: consts.MsgForUser["passwordsNotMatch"].Msg,
			Regs: nil}
		if err := tools.TmplsRenderer(w, tools.BaseTmpl, "SetFirstTimePassword", data); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
		return
	}

	if err := tools.PasswordValidate(password); err != nil {
		data := structs.MsgForUser{Msg: consts.MsgForUser["invalidPassword"].Msg,
			Regs: nil}
		if err := tools.TmplsRenderer(w, tools.BaseTmpl, "SetFirstTimePassword", data); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
		return
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err := data.SetPasswordInDbByTemporaryId(temporaryId, hashedPassword); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	successmsg := "Password has been set successfully."
	http.Redirect(w, r, consts.HomeURL+"?msg="+url.QueryEscape(successmsg), http.StatusFound)
}

routesProtector.go
package auth

import (
	"net/http"

	"github.com/gimaevra94/auth/app/consts"
	"github.com/gimaevra94/auth/app/data"
	"github.com/gimaevra94/auth/app/tools"
)

func AuthGuardForHomePath(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		Cookies, err := data.GetTemporaryIdFromCookies(r)
		if err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.SignUpURL)
			return
		}
		temporaryId := Cookies.Value

		login, email, permanentId, temporaryIdCancelled, err := data.GetAllUserKeysFromDb(temporaryId)
		if err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}

		if temporaryIdCancelled {
			Revocate(w, r, true, false, false)
			http.Redirect(w, r, consts.SignUpURL, http.StatusFound)
			return
		}

		_, userAgent, refreshTokenCancelled, err := data.GetAllRefreshTokenKeysFromDb(permanentId, r.UserAgent())
		if err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}

		if userAgent != r.UserAgent() {
			if err := tools.SuspiciousLoginEmailSend(email, login, r.UserAgent()); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.SignUpURL)
				return
			}

			Revocate(w, r, true, true, true)
			http.Redirect(w, r, consts.SignUpURL, http.StatusFound)
			return
		}

		if refreshTokenCancelled {
			Revocate(w, r, true, true, false)
			if err := tools.SuspiciousLoginEmailSend(email, login, userAgent); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}

			http.Redirect(w, r, consts.SignUpURL, http.StatusFound)
			return
		}

		next.ServeHTTP(w, r)
	})
}

func AuthGuardForSignInPath(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		Cookies, err := data.GetTemporaryIdFromCookies(r)
		if err != nil {
			next.ServeHTTP(w, r)
			return
		}

		temporaryId := Cookies.Value
		permanentId, temporaryIdCancelled, err := data.GetpermanentIdAndTemporaryIdCancelledFromDb(temporaryId)
		if err != nil || temporaryIdCancelled {
			next.ServeHTTP(w, r)
			return
		}

		_, _, refreshTokenCancelled, err := data.GetAllRefreshTokenKeysFromDb(permanentId, r.UserAgent())
		if err != nil || refreshTokenCancelled {
			next.ServeHTTP(w, r)
			return
		}

		http.Redirect(w, r, consts.HomeURL, http.StatusFound)
	})
}

func AuthGuardForSignUpPath(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		user, err := data.GetUserFromSession(r)
		if err != nil {
			http.Redirect(w, r, consts.SignUpURL, http.StatusFound)
			return
		}

		if user.ServerCode == "" {
			http.Redirect(w, r, consts.SignUpURL, http.StatusFound)
			return
		}

		next.ServeHTTP(w, r)
	})
}

func ResetTokenGuard(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := r.URL.Query().Get("token")
		if token == "" {
			http.Redirect(w, r, consts.PasswordResetURL, http.StatusFound)
			return
		}

		if _, err := tools.ResetTokenValidate(token); err != nil {
			http.Redirect(w, r, consts.PasswordResetURL, http.StatusFound)
			return
		}

		if cancelled, err := data.GetResetTokenCancelledFromDb(token); err != nil || cancelled {
			http.Redirect(w, r, consts.PasswordResetURL, http.StatusFound)
			return
		}
		next.ServeHTTP(w, r)
	})
}

signin.go
package auth

import (
	"database/sql"
	"net/http"
	"strings"

	"github.com/gimaevra94/auth/app/consts"
	"github.com/gimaevra94/auth/app/data"
	"github.com/gimaevra94/auth/app/structs"
	"github.com/gimaevra94/auth/app/tools"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"golang.org/x/crypto/bcrypt"
)

func ValidateSignInInput(w http.ResponseWriter, r *http.Request) {
	var user structs.User
	var showCaptcha bool
	login := r.FormValue("login")
	password := r.FormValue("password")
	user = structs.User{
		Login:    login,
		Password: password,
	}

	captchaCounter, err := data.GetCaptchaCounterFromSession(r)
	if err != nil {
		if strings.Contains(err.Error(), "exist") {
			captchaCounter = 3
			if err := data.SetCaptchaDataInSession(w, r, "captchaCounter", captchaCounter); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
			return
		}
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	showCaptcha, err = data.GetShowCaptchaFromSession(r)
	if err != nil {
		if strings.Contains(err.Error(), "exist") {
			showCaptcha = false
			if err := data.SetCaptchaDataInSession(w, r, "showCaptcha", showCaptcha); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
			return
		}
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if showCaptcha {
		if err := tools.ShowCaptcha(r); err != nil {
			if strings.Contains(err.Error(), "captchaToken not exist") {
				data := structs.SignInPageData{Msg: consts.MsgForUser["captchaRequired"].Msg, ShowCaptcha: showCaptcha, Regs: nil}
				if err := tools.TmplsRenderer(w, tools.BaseTmpl, "signIn", data); err != nil {
					tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
					return
				}
				return
			}
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
	}

	_, err = tools.InputValidate(r, user.Login, "", user.Password, true)
	if err != nil {
		if strings.Contains(err.Error(), "login") || strings.Contains(err.Error(), "password") {
			if err := tools.UpdateCaptchaState(w, r, captchaCounter, showCaptcha); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
			return
		}
	}

	if err := data.SetAuthSessionData(w, r, user); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	CheckSignInUserInDb(w, r)
}

func CheckSignInUserInDb(w http.ResponseWriter, r *http.Request) {
	user, err := data.GetUserFromSession(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	captchaCounter, err := data.GetCaptchaCounterFromSession(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	showCaptcha, err := data.GetShowCaptchaFromSession(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	passwordHash, permanentId, err := data.GetPasswordHashAndpermanentIdFromDb(user.Login, user.Password)
	if err != nil {
		if strings.Contains(err.Error(), "password not found") || errors.Is(err, sql.ErrNoRows) || errors.Is(err, bcrypt.ErrMismatchedHashAndPassword) {
			if err := tools.UpdateCaptchaState(w, r, captchaCounter, showCaptcha); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
			return
		}
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if !passwordHash.Valid {
		if err := tools.UpdateCaptchaState(w, r, captchaCounter, showCaptcha); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
		return
	}

	if err = bcrypt.CompareHashAndPassword([]byte(passwordHash.String), []byte(user.Password)); err != nil {
		if err := tools.UpdateCaptchaState(w, r, captchaCounter, showCaptcha); err != nil {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
		return
	}

	temporaryId := uuid.New().String()
	data.SetTemporaryIdInCookies(w, temporaryId)
	rememberMe := r.FormValue("rememberMe") != ""

	refreshToken, err := tools.GeneraterefreshToken(consts.RefreshTokenExp7Days, rememberMe)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	uniqueUserAgents, err := data.GetUniqueUserAgentsFromDb(permanentId)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	} else {
		isNewDevice := true
		for _, userAgent := range uniqueUserAgents {
			if userAgent == r.UserAgent() {
				isNewDevice = false
				break
			}
		}

		if isNewDevice {
			if err := tools.SendNewDeviceLoginEmail(user.Login, user.Email, r.UserAgent()); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
		}
	}

	tx, err := data.Db.Begin()
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	defer func() {
		if err := recover(); err != nil {
			tx.Rollback()
			panic(err)
		}
	}()

	temporaryIdCancelled := false
	if err = data.SetTemporaryIdInDbByEmailTx(tx, user.Login, temporaryId, temporaryIdCancelled); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	refreshTokenCancelled := false
	if err = data.SetRefreshTokenInDbTx(tx, permanentId, refreshToken, r.UserAgent(), refreshTokenCancelled); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err = tx.Commit(); err != nil {
		tx.Rollback()
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	captchaCounter = 3
	if err = data.SetCaptchaDataInSession(w, r, "captchaCounter", captchaCounter); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return

	}

	showCaptcha = false
	if err = data.SetCaptchaDataInSession(w, r, "showCaptcha", showCaptcha); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err = data.EndAuthSession(w, r); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	http.Redirect(w, r, consts.HomeURL, http.StatusFound)
}

signup.go
package auth

import (
	"database/sql"
	"net/http"
	"strings"

	"github.com/gimaevra94/auth/app/consts"
	"github.com/gimaevra94/auth/app/data"
	"github.com/gimaevra94/auth/app/structs"
	"github.com/gimaevra94/auth/app/tools"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"

	"github.com/pkg/errors"
)

func ValidateSignUpInput(w http.ResponseWriter, r *http.Request) {
	var user structs.User
	var ShowCaptcha bool
	login := r.FormValue("login")
	email := r.FormValue("email")
	password := r.FormValue("password")
	user = structs.User{
		Login:    login,
		Email:    email,
		Password: password,
	}

	captchaCounter, err := data.GetCaptchaCounterFromSession(r)
	if err != nil {
		if strings.Contains(err.Error(), "exist") {
			captchaCounter = 3
			if err := data.SetCaptchaDataInSession(w, r, "captchaCounter", captchaCounter); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
		}
	}

	ShowCaptcha, err = data.GetShowCaptchaFromSession(r)
	if err != nil {
		if strings.Contains(err.Error(), "exist") {
			ShowCaptcha = false
			if err := data.SetCaptchaDataInSession(w, r, "ShowCaptcha", ShowCaptcha); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
		}
	}

	if ShowCaptcha && r.Method == "POST" {
		if err := tools.ShowCaptcha(r); err != nil {
			if strings.Contains(err.Error(), "captchaToken not exist") {
				data := structs.SignUpPageData{Msg: consts.MsgForUser["captchaRequired"].Msg, ShowCaptcha: ShowCaptcha, Regs: nil}
				if err := tools.TmplsRenderer(w, tools.BaseTmpl, "signUp", data); err != nil {
					tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
					return
				}
				return
			}
		}
	}

	errmsgKey, err := tools.InputValidate(r, user.Login, user.Email, user.Password, false)
	if err != nil {
		if strings.Contains(err.Error(), "login") || strings.Contains(err.Error(), "email") || strings.Contains(err.Error(), "password") {
			data := structs.SignUpPageData{
				Msg:         consts.MsgForUser[errmsgKey].Msg,
				ShowCaptcha: ShowCaptcha,
				Regs:        consts.MsgForUser[errmsgKey].Regs,
			}
			tools.UpdateCaptchaState(w, r, captchaCounter-1, ShowCaptcha)
			if err := tools.TmplsRenderer(w, tools.BaseTmpl, "signUp", data); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
		}
		return
	}

	if err := data.SetAuthSessionData(w, r, user); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	CheckSignUpUserInDb(w, r)
}

func CheckSignUpUserInDb(w http.ResponseWriter, r *http.Request) {

	user, err := data.GetUserFromSession(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	captchaCounter, err := data.GetCaptchaCounterFromSession(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	ShowCaptcha, err := data.GetShowCaptchaFromSession(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	_, err = data.GetPermanentIdFromDb(user.Email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			CodeSend(w, r)
			return
		}
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err := tools.UpdateCaptchaState(w, r, captchaCounter-1, ShowCaptcha); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

func CodeSend(w http.ResponseWriter, r *http.Request) {
	user, err := data.GetUserFromSession(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if user.ServerCode != "" {
		err := errors.New("code already sent")
		tracedErr := errors.WithStack(err)
		tools.LogAndRedirectIfErrNotNill(w, r, tracedErr, consts.CodeSendURL)
		return
	}

	serverCode, err := tools.ServerAuthCodeSend(user.Email)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
	user.ServerCode = serverCode

	if err := data.SetAuthSessionData(w, r, user); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if r.URL.Path != consts.CodeSendURL {
		http.Redirect(w, r, consts.CodeSendURL, http.StatusFound)
		return
	}
}

func SetUserInDb(w http.ResponseWriter, r *http.Request) {
	user, err := data.GetUserFromSession(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	clientCode := r.FormValue("clientCode")
	if err := tools.CodeValidate(r, clientCode, user.ServerCode); err != nil {
		if strings.Contains(err.Error(), "exist") {
			data := structs.MsgForUser{Msg: consts.MsgForUser["userCode"].Msg, Regs: nil}
			if err := tools.TmplsRenderer(w, tools.BaseTmpl, "CodeSend", data); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
			return
		} else if strings.Contains(err.Error(), "match") {
			data := structs.MsgForUser{Msg: consts.MsgForUser["serverCode"].Msg, Regs: nil}
			if err := tools.TmplsRenderer(w, tools.BaseTmpl, "CodeSend", data); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
			return
		}
	}

	rememberMe := r.FormValue("rememberMe") != ""
	refreshToken, err := tools.GeneraterefreshToken(consts.RefreshTokenExp7Days, rememberMe)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	tx, err := data.Db.Begin()
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
	defer func() {
		r := recover()
		if r != nil {
			tx.Rollback()
			panic(r)
		}
	}()

	temporaryId := uuid.New().String()
	data.SetTemporaryIdInCookies(w, temporaryId)
	permanentId := uuid.New().String()
	temporaryIdCancelled := false

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password),
		bcrypt.DefaultCost)
	if err != nil {
		return
	}

	if err := data.SetUserInDbTx(tx, user.Login, user.Email, permanentId, temporaryId, hashedPassword, temporaryIdCancelled); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	refreshTokenCancelled := false
	if err = data.SetRefreshTokenInDbTx(tx, permanentId, refreshToken, r.UserAgent(), refreshTokenCancelled); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err = tx.Commit(); err != nil {
		tx.Rollback()
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err = tools.SendNewDeviceLoginEmail(user.Email, user.Login, r.UserAgent()); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
	}

	captchaCounter := 3
	if err = data.SetCaptchaDataInSession(w, r, "captchaCounter", captchaCounter); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	ShowCaptcha := false
	if err = data.SetCaptchaDataInSession(w, r, "ShowCaptcha", ShowCaptcha); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err = data.EndAuthSession(w, r); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	http.Redirect(w, r, consts.HomeURL, http.StatusFound)
}

yauth.go
package auth

import (
	"database/sql"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"os"

	"github.com/gimaevra94/auth/app/consts"
	"github.com/gimaevra94/auth/app/data"
	"github.com/gimaevra94/auth/app/structs"
	"github.com/gimaevra94/auth/app/tools"
	"github.com/google/uuid"
	"github.com/pkg/errors"
)

const (
	authURL               = "https://oauth.yandex.ru/authorize"
	tokenURL              = "https://oauth.yandex.ru/token"
	userInfoURL           = "https://login.yandex.ru/info"
	YandexCallbackFullURL = "http://localhost:8080/ya_callback"
)

func YandexAuthHandler(w http.ResponseWriter, r *http.Request) {
	authParams := url.Values{
		"response_type": {"code"},
		"client_Id":     {os.Getenv("clientId")},
		"redirect_uri":  {YandexCallbackFullURL},
		"scope":         {"login:email"},
	}
	authUrlWithParams := authURL + "?" + authParams.Encode()
	http.Redirect(w, r, authUrlWithParams, http.StatusFound)
}

func YandexCallbackHandler(w http.ResponseWriter, r *http.Request) {
	yauthCode := r.URL.Query().Get("code")
	if yauthCode == "" {
		err := errors.New("yauthCode not exist")
		tracedErr := errors.WithStack(err)
		tools.LogAndRedirectIfErrNotNill(w, r, tracedErr, consts.SignUpURL)
		return
	}

	yandexAccessToken, err := getAccessToken(yauthCode)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	yandexUser, err := getYandexUserInfo(yandexAccessToken)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	tx, err := data.Db.Begin()
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	defer func() {
		if err := recover(); err != nil {
			tx.Rollback()
			panic(err)
		}
	}()

	temporaryId := uuid.New().String()
	permanentId := uuid.New().String()
	temporaryIdCancelled := false

	bdPermanentId, err := data.GetPermanentIdFromDb(yandexUser.Email)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			if err = data.SetYauthUserInDbTx(tx, yandexUser.Login, yandexUser.Email, temporaryId, permanentId, temporaryIdCancelled); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
		} else {
			tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
			return
		}
	}

	if bdPermanentId != "" {
		permanentId = bdPermanentId
	}
	data.SetTemporaryIdInCookies(w, temporaryId)

	if err = data.SetTemporaryIdInDbByEmailTx(tx, yandexUser.Login, temporaryId, temporaryIdCancelled); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	rememberMe := r.FormValue("rememberMe") != ""
	refreshToken, err := tools.GeneraterefreshToken(consts.RefreshTokenExp7Days, rememberMe)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	uniqueUserAgents, err := data.GetUniqueUserAgentsFromDb(permanentId)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	} else {
		isNewDevice := true
		for _, userAgent := range uniqueUserAgents {
			if userAgent == r.UserAgent() {
				isNewDevice = false
				break
			}
		}

		if isNewDevice {
			if err := tools.SendNewDeviceLoginEmail(yandexUser.Login, yandexUser.Email, r.UserAgent()); err != nil {
				tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
				return
			}
		}
	}

	refreshTokenCancelled := false
	if err = data.SetRefreshTokenInDbTx(tx, permanentId, refreshToken, r.UserAgent(), refreshTokenCancelled); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if err = tx.Commit(); err != nil {
		tx.Rollback()
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	http.Redirect(w, r, consts.HomeURL, http.StatusFound)
}

func getAccessToken(yauthCode string) (string, error) {
	tokenParams := url.Values{
		"grant_type":    {"authorization_code"},
		"code":          {yauthCode},
		"client_Id":     {os.Getenv("clientId")},
		"client_secret": {os.Getenv("clientSecret")},
		"redirect_uri":  {YandexCallbackFullURL},
	}

	resp, err := http.PostForm(tokenURL, tokenParams)
	if err != nil {
		return "", errors.WithStack(err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", errors.WithStack(err)
	}

	var result map[string]interface{}
	if err = json.Unmarshal(body, &result); err != nil {
		return "", errors.WithStack(err)
	}

	accessToken, ok := result["access_token"].(string)
	if !ok {
		err := errors.New("access_token: not exist")
		return "", errors.WithStack(err)
	}

	return accessToken, nil
}

func getYandexUserInfo(accessToken string) (structs.User, error) {
	userInfoURLWithParams := userInfoURL + "?format=json&with_openId_Identity=1&with_email=1"

	req, err := http.NewRequest("GET", userInfoURLWithParams, nil)
	if err != nil {
		return structs.User{}, errors.WithStack(err)
	}

	req.Header.Set("Authorization", "OAuth "+accessToken)
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return structs.User{}, errors.WithStack(err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return structs.User{}, errors.WithStack(err)
	}

	var user structs.User
	if err = json.Unmarshal(body, &user); err != nil {
		return structs.User{}, errors.WithStack(err)
	}

	return user, nil
}

consts.go
package consts

import "github.com/gimaevra94/auth/app/structs"

const (
	SignUpURL        = "/sign-up"
	CodeSendURL      = "/code-send"
	SignInURL        = "/sign-in"
	PasswordResetURL = "/password-reset"
	HomeURL          = "/home"
	Err500URL        = "/500"
)

const RefreshTokenExp7Days = 7 * 24 * 60 * 60

const (
	successfulMailSendingStatus = "Mail sent successfully"
	failedMailSendingStatus     = "Failed to send mail"
	invalidLogin                = "Login is invalid"
	invalidEmail                = "Email is invalid"
	invalidPassword             = "Password is invalid"
	userAlreadyExist            = "User already exists"
	userNotExist                = "User does not exist"
	serverCodeMsg               = "Wrong code"
	userCodeMsg                 = "User code is empty"
	captchaRequiredMsg          = "Pass the verification reCAPTCHA."
	passwordsNotMatch           = "Passwords do not match"
)

var (
	loginReqs = []string{
		"3-30 characters long",
		"Latin or Cyrillic letters",
		"Numbers 0-9",
	}
	emailReqs = []string{
		"Must contain Latin letters, numbers and allowed special characters: . _ % + -",
		"Must contain exactly one '@' symbol",
		"Domain must be valId and end with .com, .org, etc.",
	}
	PswrdReqs = []string{
		"8-30 characters long",
		"Latin letters only",
		"Numbers 0-9",
		"Special symbols: !@#$%^&*",
	}
)

var MsgForUser = map[string]structs.MsgForUser{
	"loginInvalid":                {Msg: invalidLogin, Regs: loginReqs},
	"emailInvalid":                {Msg: invalidEmail, Regs: emailReqs},
	"captchaRequired":             {Msg: captchaRequiredMsg, Regs: nil},
	"passwordInvalid":             {Msg: invalidPassword, Regs: PswrdReqs},
	"passwordsNotMatch":           {Msg: passwordsNotMatch, Regs: nil},
	"serverCode":                  {Msg: serverCodeMsg, Regs: nil},
	"userCode":                    {Msg: userCodeMsg, Regs: nil},
	"userAlreadyExist":            {Msg: userAlreadyExist, Regs: nil},
	"userNotExist":                {Msg: userNotExist, Regs: nil},
	"successfulMailSendingStatus": {Msg: successfulMailSendingStatus, Regs: nil},
	"failedMailSendingStatus":     {Msg: failedMailSendingStatus, Regs: nil},
}

cookies.go
package data

import (
	"net/http"

	"github.com/gimaevra94/auth/app/consts"
	"github.com/pkg/errors"
)

const temporaryIdExp = 30 * 24 * 60 * 60

func SetTemporaryIdInCookies(w http.ResponseWriter, v string) {
	http.SetCookie(w, &http.Cookie{
		Name:     "temporaryId",
		Path:     "/",
		HttpOnly: true,
		Secure:   false,
		SameSite: http.SameSiteLaxMode,
		Value:    v,
		MaxAge:   temporaryIdExp,
	})
}

func GetTemporaryIdFromCookies(r *http.Request) (*http.Cookie, error) {
	Cookies, err := r.Cookie("temporaryId")
	if err != nil {
		return nil, errors.WithStack(err)
	}
	if Cookies.Value == "" {
		return nil, errors.New("temporaryId not exist")
	}
	return Cookies, nil
}

func ClearTemporaryIdInCookies(w http.ResponseWriter) {
	http.SetCookie(w, &http.Cookie{
		Name:     "temporaryId",
		Path:     "/",
		HttpOnly: true,
		Secure:   false,
		SameSite: http.SameSiteLaxMode,
		MaxAge:   -1,
	})
}

func ClearCookiesDev(w http.ResponseWriter, r *http.Request) {
	ClearTemporaryIdInCookies(w)
	if err := EndAuthSession(w, r); err != nil {
		errors.WithStack(err)
	}
	if err := EndCaptchaSession(w, r); err != nil {
		errors.WithStack(err)
	}
	http.Redirect(w, r, consts.SignUpURL, http.StatusFound)
}

database.go
package data

import (
	"database/sql"
	"os"

	"github.com/go-sql-driver/mysql"
	"github.com/pkg/errors"
	"golang.org/x/crypto/bcrypt"
)

const (
	permanentIdSelectQuery                        = "select permanentId from user where email = ?"
	passwordSelectQuery                           = "select passwordHash from user where temporaryId = ?"
	allUserKeysSelectQuery                        = "select login, email, permanentId, temporaryIdCancelled from user where temporaryId = ? limit 1"
	passwordHashAndPermanentIdSelectQuery         = "select passwordHash, permanentId from user where login = ? limit 1"
	passwordHashSelectQuery                       = "select passwordHash from user where login = ? limit 1"
	permanentIdAndTemporaryIdCancelledSelectQuery = "select permanentId, temporaryIdCancelled from user where temporaryId = ? limit 1"
	uniqueUserAgentsSelectQuery                   = "select distinct userAgent FROM refresh_token WHERE permanentId = ?"
	allRefreshTokenKeysSelectQuery                = "select refreshToken, userAgent, refreshTokenCancelled from refresh_token where permanentId = ? and userAgent = ? AND refreshTokenCancelled = FALSE limit 1"
	resetTokenCancelledSelectQuery                = "select cancelled from reset_token where token = ?"

	userInsertQuery               = "insert into user (login, email, passwordHash, temporaryId, permanentId, temporaryIdCancelled) values (?, ?, ?, ?, ?, ?)"
	yauthUserInsertQuery          = "insert into user (login, email, temporaryId, permanentId, temporaryIdCancelled) values (?, ?, ?, ?, ?)"
	refreshTokenInsertQuery       = "insert into refresh_token (permanentId, refreshToken, userAgent, refreshTokenCancelled) values (?, ?, ?, ?)"
	passwordResetTokenInsertQuery = "insert into reset_token (token, cancelled) values (?, ?)"

	passwordInDbByEmailUpdateQuery         = "update user set passwordHash = ? where email = ?"
	passwordInDbByPermanentIdUpdateQuery   = "update user set passwordHash = ? where temporaryId = ?"
	temporaryIdInDbByLoginUpdateQuery      = "update user set temporaryId = ?, temporaryIdCancelled = ? where login = ?"
	temporaryIdInDbByEmailUpdateQuery      = "update user set temporaryId = ?, temporaryIdCancelled = ? where email = ?"
	refreshTokenCancelledUpdateQuery       = "update refresh_token set refreshTokenCancelled = ? where refreshToken = ? and userAgent = ?"
	temporaryIdCancelledUpdateQuery        = "update user set temporaryIdCancelled = ? where temporaryId = ?"
	passwordResetTokenCancelledUpdateQuery = "update reset_token set cancelled = TRUE where token = ?"
)

var Db *sql.DB

func DbConn() error {
	DbPassword := []byte(os.Getenv("DB_PASSWORD"))
	cfg := mysql.Config{
		User:   "root",
		Passwd: string(DbPassword),
		Net:    "tcp",
		Addr:   "localhost:3306",
		DBName: "db",
	}
	var err error

	Db, err = sql.Open("mysql", cfg.FormatDSN())
	if err != nil {
		return errors.WithStack(err)
	}
	if err = Db.Ping(); err != nil {
		Db.Close()
		return errors.WithStack(err)
	}
	return nil
}

func DbClose() {
	if Db != nil {
		Db.Close()
	}
}

func GetPermanentIdFromDb(Email string) (string, error) {
	var permanentId string
	row := Db.QueryRow(permanentIdSelectQuery, Email)
	err := row.Scan(&permanentId)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", errors.WithStack(err)
		}
		return "", errors.WithStack(err)
	}
	return permanentId, nil
}

func GetPasswordFromDb(temporaryId string) (string, error) {
	var passwordHash sql.NullString
	row := Db.QueryRow(passwordInDbByPermanentIdUpdateQuery, temporaryId)
	err := row.Scan(&passwordHash)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", errors.WithStack(err)
		}
		return "", errors.WithStack(err)
	}
	return passwordHash.String, nil
}

func GetAllUserKeysFromDb(temporaryId string) (string, string, string, bool, error) {
	var login string
	var email string
	var permanentId string
	var temporaryIdCancelled bool
	row := Db.QueryRow(allUserKeysSelectQuery, temporaryId)
	err := row.Scan(&login, &email, &permanentId, &temporaryIdCancelled)
	if err != nil {
		return "", "", "", false, errors.WithStack(err)
	}
	return login, email, permanentId, temporaryIdCancelled, nil
}

func GetPasswordHashFromDb(temporaryId string) (sql.NullString, error) {
	var passwordHash sql.NullString
	row := Db.QueryRow(passwordHashSelectQuery, temporaryId)
	err := row.Scan(&passwordHash)
	if err != nil {
		if err == sql.ErrNoRows {
			return sql.NullString{}, errors.WithStack(err)
		}
		return sql.NullString{}, errors.WithStack(err)
	}
	return passwordHash, nil
}

func GetPasswordHashAndpermanentIdFromDb(login, password string) (sql.NullString, string, error) {
	var passwordHash sql.NullString
	var permanentId string
	row := Db.QueryRow(passwordHashAndPermanentIdSelectQuery, login)
	err := row.Scan(&passwordHash, &permanentId)
	if err != nil {
		if err == sql.ErrNoRows {
			return sql.NullString{}, "", errors.WithStack(err)
		}
		return sql.NullString{}, "", errors.WithStack(err)
	}
	return passwordHash, permanentId, nil
}

func GetpermanentIdAndTemporaryIdCancelledFromDb(temporaryId string) (string, bool, error) {
	var permanentId string
	var temporaryIdCancelled bool
	row := Db.QueryRow(permanentIdAndTemporaryIdCancelledSelectQuery, temporaryId)
	err := row.Scan(&permanentId, &temporaryIdCancelled)
	if err != nil {
		return "", false, errors.WithStack(err)
	}
	return permanentId, temporaryIdCancelled, nil
}

func GetUniqueUserAgentsFromDb(permanentId string) ([]string, error) {
	rows, err := Db.Query(uniqueUserAgentsSelectQuery, permanentId)
	if err != nil {
		return nil, errors.WithStack(err)
	}
	defer rows.Close()

	var userAgents []string
	for rows.Next() {
		var userAgent string
		if err := rows.Scan(&userAgent); err != nil {
			return nil, errors.WithStack(err)
		}
		userAgents = append(userAgents, userAgent)
	}

	if err = rows.Err(); err != nil {
		return nil, errors.WithStack(err)
	}

	return userAgents, nil
}

func GetAllRefreshTokenKeysFromDb(permanentId, userAgent string) (string, string, bool, error) {
	var refreshToken string
	var dbUserAgent string
	var refreshTokenCancelled bool
	row := Db.QueryRow(allRefreshTokenKeysSelectQuery, permanentId, userAgent)
	err := row.Scan(&refreshToken, &dbUserAgent, &refreshTokenCancelled)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", "", false, errors.WithStack(err)
		}
		return "", "", false, errors.WithStack(err)
	}
	return refreshToken, dbUserAgent, refreshTokenCancelled, nil
}

func GetResetTokenCancelledFromDb(signedToken string) (bool, error) {
	var cancelled bool
	row := Db.QueryRow(resetTokenCancelledSelectQuery, signedToken)
	err := row.Scan(&cancelled)
	if err != nil {
		if err == sql.ErrNoRows {
			return false, errors.New("reset token not found or invalid")
		}
		return false, errors.WithStack(err)
	}
	return cancelled, nil
}

func SetUserInDbTx(tx *sql.Tx, login, email, temporaryId, permanentId string, hashedPassword []byte, temporaryIdCancelled bool) error {
	_, err := tx.Exec(userInsertQuery, login, email, hashedPassword, temporaryId, permanentId, temporaryIdCancelled)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SetYauthUserInDbTx(tx *sql.Tx, login, email, temporaryId, permanentId string, temporaryIdCancelled bool) error {
	_, err := tx.Exec(yauthUserInsertQuery, login, email, temporaryId, permanentId, temporaryIdCancelled)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SetPasswordInDbByEmailTx(tx *sql.Tx, email, newPassword string) error {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword),
		bcrypt.DefaultCost)
	if err != nil {
		return errors.WithStack(err)
	}
	_, err = tx.Exec(passwordInDbByEmailUpdateQuery, hashedPassword, email)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SetPasswordInDbByTemporaryId(temporaryId string, hashedPassword []byte) error {
	_, err := Db.Exec(passwordInDbByPermanentIdUpdateQuery, hashedPassword, temporaryId)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SettemporaryIdInDbByLoginTx(tx *sql.Tx, login, temporaryId string, temporaryIdCancelled bool) error {
	_, err := tx.Exec(temporaryIdInDbByLoginUpdateQuery, temporaryId, temporaryIdCancelled, login)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SetTemporaryIdInDbByEmailTx(tx *sql.Tx, email, temporaryId string, temporaryIdCancelled bool) error {
	_, err := tx.Exec(temporaryIdInDbByEmailUpdateQuery, temporaryId, temporaryIdCancelled, email)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SetRefreshTokenInDbTx(tx *sql.Tx, permanentId, refreshToken, userAgent string, refreshTokenCancelled bool) error {
	_, err := tx.Exec(refreshTokenInsertQuery, permanentId, refreshToken, userAgent, refreshTokenCancelled)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SetPasswordResetTokenInDbTx(tx *sql.Tx, resetToken string) error {
	_, err := tx.Exec(passwordResetTokenInsertQuery, resetToken, false)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SetRefreshTokenCancelledInDbTx(tx *sql.Tx, refreshToken, userAgent string) error {
	_, err := tx.Exec(refreshTokenCancelledUpdateQuery, true, refreshToken, userAgent)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SetTemporaryIdCancelledInDbTx(tx *sql.Tx, temporaryId string) error {
	_, err := tx.Exec(temporaryIdCancelledUpdateQuery, true, temporaryId)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func SetPasswordResetTokenCancelledInDbTx(tx *sql.Tx, resetToken string) error {
	_, err := tx.Exec(passwordResetTokenCancelledUpdateQuery, resetToken)
	if err != nil {
		return errors.WithStack(err)
	}
	return nil
}

sessions.go
package data

import (
	"encoding/json"
	"net/http"
	"os"

	"github.com/gimaevra94/auth/app/structs"
	"github.com/gorilla/sessions"
	"github.com/pkg/errors"
)

var loginStore *sessions.CookieStore
var captchaStore *sessions.CookieStore

func InitStore() *sessions.CookieStore {
	sessionAuthKey := []byte(os.Getenv("LOGIN_STORE_SESSION_AUTH_KEY"))
	sessionEncryptionKey := []byte(os.Getenv("LOGIN_STORE_SESSION_ENCRYPTION_KEY"))
	loginStore = sessions.NewCookieStore(sessionAuthKey, sessionEncryptionKey)
	loginStoreLifeTime := 30 * 60

	loginStore.Options = &sessions.Options{
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
		Path:     "/",
		MaxAge:   loginStoreLifeTime,
		Secure:   false,
	}

	sessionSecret := []byte(os.Getenv("CAPTCHA_STORE_SESSION_SECRET_KEY"))
	captchaStore = sessions.NewCookieStore(sessionSecret)
	captchaStoreLifeTime := 30 * 24 * 60 * 60

	captchaStore.Options = &sessions.Options{
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
		Path:     "/",
		MaxAge:   captchaStoreLifeTime,
		Secure:   false,
	}

	return nil
}

func SetCaptchaDataInSession(w http.ResponseWriter, r *http.Request, key string, consts any) error {
	captchaSession, err := captchaStore.Get(r, "captchaStore")
	if err != nil {
		return errors.WithStack(err)
	}

	jsonData, err := json.Marshal(consts)
	if err != nil {
		return errors.WithStack(err)
	}

	captchaSession.Values[key] = jsonData
	err = captchaSession.Save(r, w)
	if err != nil {
		return errors.WithStack(err)
	}

	return nil
}

func SetAuthSessionData(w http.ResponseWriter, r *http.Request, consts any) error {
	loginSession, err := loginStore.Get(r, "loginStore")
	if err != nil {
		return errors.WithStack(err)
	}

	jsonData, err := json.Marshal(consts)
	if err != nil {
		return errors.WithStack(err)
	}

	loginSession.Values["user"] = jsonData
	if err = loginSession.Save(r, w); err != nil {
		return errors.WithStack(err)
	}

	return nil
}

func GetCaptchaCounterFromSession(r *http.Request) (int64, error) {
	session, err := captchaStore.Get(r, "captchaStore")
	if err != nil {
		return 0, errors.WithStack(err)
	}

	byteData, ok := session.Values["captchaCounter"].([]byte)
	if !ok {
		err := errors.New("captchaCounter not exist")
		return 0, errors.WithStack(err)
	}

	var intData int64
	if err = json.Unmarshal([]byte(byteData), &intData); err != nil {
		return 0, errors.WithStack(err)
	}

	return intData, nil
}

func GetShowCaptchaFromSession(r *http.Request) (bool, error) {
	session, err := captchaStore.Get(r, "captchaStore")
	if err != nil {
		return false, errors.WithStack(err)
	}

	byteData, ok := session.Values["showCaptcha"].([]byte)
	if !ok {
		err := errors.New("showCaptcha not exist")
		return false, errors.WithStack(err)
	}

	var boolData bool
	if err = json.Unmarshal([]byte(byteData), &boolData); err != nil {
		return false, errors.WithStack(err)
	}

	return boolData, nil
}

func GetUserFromSession(r *http.Request) (structs.User, error) {
	session, err := loginStore.Get(r, "loginStore")
	if err != nil {
		return structs.User{}, errors.WithStack(err)
	}

	byteData, ok := session.Values["user"].([]byte)
	if !ok {
		err := errors.New("user not exist")
		return structs.User{}, errors.WithStack(err)
	}

	var userData structs.User
	if err = json.Unmarshal([]byte(byteData), &userData); err != nil {
		return structs.User{}, errors.WithStack(err)
	}

	return userData, nil
}

func EndAuthSession(w http.ResponseWriter, r *http.Request) error {
	session, err := loginStore.Get(r, "loginStore")
	if err != nil {
		return errors.WithStack(err)
	}

	session.Options.MaxAge = -1
	if err = session.Save(r, w); err != nil {
		return errors.WithStack(err)
	}

	return nil
}

func EndCaptchaSession(w http.ResponseWriter, r *http.Request) error {
	session, err := captchaStore.Get(r, "captchaStore")
	if err != nil {
		return errors.WithStack(err)
	}

	session.Options.MaxAge = -1
	if err = session.Save(r, w); err != nil {
		return errors.WithStack(err)
	}

	return nil
}

structs.go
package structs

import "github.com/golang-jwt/jwt"

type User struct {
	UserId     string `sql:"userId"`
	Login      string `sql:"login" json:"login"`
	Email      string `sql:"email" json:"default_email"`
	Password   string `sql:"passwordHash"`
	ServerCode string
}

type MsgForUser struct {
	Msg  string
	Regs []string
}

type SignUpPageData struct {
	Msg         string
	ShowCaptcha bool
	Regs        []string
}

type SignInPageData struct {
	Msg                string
	ShowForgotPassword bool
	ShowCaptcha        bool
	Regs               []string
	NoPassword         bool
}

type PasswordResetTokenClaims struct {
	jwt.StandardClaims
	Email string `json:"email"`
}

tmplsCaller.go
package tmpls

import (
	"net/http"

	"github.com/gimaevra94/auth/app/consts"
	"github.com/gimaevra94/auth/app/data"
	"github.com/gimaevra94/auth/app/structs"
	"github.com/gimaevra94/auth/app/tools"
)

func SignUp(w http.ResponseWriter, r *http.Request) {
	if err := tools.TmplsRenderer(w, tools.BaseTmpl, "signUp", nil); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

func SignIn(w http.ResponseWriter, r *http.Request) {
	if err := tools.TmplsRenderer(w, tools.BaseTmpl, "signIn", nil); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

func CodeSend(w http.ResponseWriter, r *http.Request) {
	if err := tools.TmplsRenderer(w, tools.BaseTmpl, "codeSend", nil); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

func Home(w http.ResponseWriter, r *http.Request) {
	showSetPasswordButton := true
	cookies, err := data.GetTemporaryIdFromCookies(r)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	temporaryId := cookies.Value
	passwordHash, err := data.GetPasswordHashFromDb(temporaryId)
	if err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}

	if passwordHash.String != "" {
		showSetPasswordButton = false
	}

	data := struct{ ShowSetPasswordButton bool }{ShowSetPasswordButton: showSetPasswordButton}
	if err := tools.TmplsRenderer(w, tools.BaseTmpl, "home", data); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

func Logout(w http.ResponseWriter, r *http.Request) {
	if err := tools.TmplsRenderer(w, tools.BaseTmpl, "logout", nil); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

func PasswordReset(w http.ResponseWriter, r *http.Request) {
	msg := r.URL.Query().Get("msg")
	data := structs.MsgForUser{Msg: msg}
	if err := tools.TmplsRenderer(w, tools.BaseTmpl, "passwordReset", data); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

func SetNewPassword(w http.ResponseWriter, r *http.Request) {
	data := struct {
		Msg   string
		Token string
	}{Msg: r.URL.Query().Get("msg"), Token: r.URL.Query().Get("token")}
	if err := tools.TmplsRenderer(w, tools.BaseTmpl, "setNewPassword", data); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

func SetFirstTimePassword(w http.ResponseWriter, r *http.Request) {
	data := struct {
		Msg  string
		Regs []string
	}{
		Msg:  r.URL.Query().Get("msg"),
		Regs: consts.PswrdReqs,
	}
	if err := tools.TmplsRenderer(w, tools.BaseTmpl, "setFirstTimePassword", data); err != nil {
		tools.LogAndRedirectIfErrNotNill(w, r, err, consts.Err500URL)
		return
	}
}

func Err500(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, "../public/500.html")
}

captcha.go
package tools

import (
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"os"

	"github.com/gimaevra94/auth/app/data"
	"github.com/pkg/errors"
)

func ShowCaptcha(r *http.Request) error {
	captchaToken := r.FormValue("g-recaptcha-response")
	if captchaToken == "" {
		return errors.WithStack(errors.New("captchaToken not exist"))
	}

	captchaURL := "https://www.google.com/recaptcha/api/siteverify"
	captchaParams := url.Values{
		"secret":   {os.Getenv("GOOGLE_CAPTCHA_SECRET")},
		"response": {captchaToken},
	}

	resp, err := http.PostForm(captchaURL, captchaParams)
	if err != nil {
		return errors.WithStack(err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	var result map[string]interface{}
	if err != nil {
		return errors.WithStack(err)
	}

	if err = json.Unmarshal(body, &result); err != nil {
		return errors.WithStack(err)
	}

	success, ok := result["success"].(bool)
	if !ok || !success {
		return errors.New("reCAPTCHA verification failed")
	}

	return nil
}

func UpdateCaptchaState(w http.ResponseWriter, r *http.Request, captchaCounter int64, showCaptcha bool) error {
	if err := data.SetCaptchaDataInSession(w, r, "captchaCounter", captchaCounter); err != nil {
		return errors.WithStack(err)
	}

	if captchaCounter <= 1 {
		showCaptcha = true
	}

	if err := data.SetCaptchaDataInSession(w, r, "showCaptcha", showCaptcha); err != nil {
		return errors.WithStack(err)
	}

	return nil
}

errs.go
package tools

import (
	"log"
	"net/http"
	"strings"

	"github.com/gimaevra94/auth/app/consts"
)

func LogAndRedirectIfErrNotNill(w http.ResponseWriter, r *http.Request, err error, url string) {
	if err != nil {
		log.Printf("%+v", err)
		if url == "" || !strings.HasPrefix(r.URL.Path, "/") {
			http.Redirect(w, r, consts.Err500URL, http.StatusFound)
			return
		}
	} else {
		http.Redirect(w, r, url, http.StatusFound)
		return
	}
}

mailsender.go
package tools

import (
	"bytes"
	"math/rand"
	"net/smtp"
	"os"

	"strconv"
	"time"

	"github.com/pkg/errors"
)

var (
	serverEmail            = os.Getenv("SERVER_EMAIL")
	authCodeSubject        = "Auth code"
	suspiciousLoginSubject = "Suspicious login alert!"
	newDeviceLoginSubject  = "New device login"
	passwordResetSubject   = "Password reset request"
)

func serverAuthCodeGenerate() string {
	randomState := rand.New(rand.NewSource(time.Now().UnixNano()))
	AuthServerCodeItn := randomState.Intn(9000) + 1000
	AuthServerCode := strconv.Itoa(AuthServerCodeItn)
	return AuthServerCode
}

func SendNewDeviceLoginEmail(userEmail, login, userAgent string) error {
	sMTPServerAuthSubject, sMTPServerAddr := sMTPServerAuth(serverEmail)
	data := struct {
		login     string
		userAgent string
	}{login: login, userAgent: userAgent}

	msg, err := executeTmpl(serverEmail, userEmail, newDeviceLoginSubject, data)
	if err != nil {
		return errors.WithStack(err)
	}

	if err := mailSend(serverEmail, userEmail, sMTPServerAuthSubject, sMTPServerAddr, msg); err != nil {
		return errors.WithStack(err)
	}

	return nil
}

func sMTPServerAuth(serverEmail string) (smtp.Auth, string) {
	serverPassword := os.Getenv("SERVER_EMAIL_PASSWORD")
	sMTPServerAddr := "smtp.yandex.ru"
	sMTPServerAuthSubject := smtp.PlainAuth("", serverEmail, serverPassword, sMTPServerAddr)
	return sMTPServerAuthSubject, sMTPServerAddr
}

func mailSend(serverEmail, userEmail string, sMTPServerAuthSubject smtp.Auth, sMTPServerAddr string, msg []byte) error {
	from := serverEmail
	to := []string{userEmail}
	addr := sMTPServerAddr
	if err := smtp.SendMail(addr, sMTPServerAuthSubject, from, to, msg); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

func executeTmpl(serverEmail, userEmail, emailSubject string, data any) ([]byte, error) {
	var body bytes.Buffer

	switch emailSubject {
	case authCodeSubject:
		if err := BaseTmpl.ExecuteTemplate(&body, "emailMsgWithServerAuthCode", data); err != nil {
			return []byte{}, errors.WithStack(err)
		}

	case suspiciousLoginSubject:
		if err := BaseTmpl.ExecuteTemplate(&body, "emailMsgAboutSuspiciousLoginEmail", data); err != nil {
			return []byte{}, errors.WithStack(err)
		}

	case newDeviceLoginSubject:
		if err := BaseTmpl.ExecuteTemplate(&body, "emailMsgAboutNewDeviceLoginEmail", data); err != nil {
			return []byte{}, errors.WithStack(err)
		}

	case passwordResetSubject:
		if err := BaseTmpl.ExecuteTemplate(&body, "generatePasswordResetLink", data); err != nil {
			return []byte{}, errors.WithStack(err)
		}
	}

	msg := []byte(
		"From: " + serverEmail + "\r\n" +
			"To: " + userEmail + "\r\n" +
			"Subject: " + emailSubject + "\r\n" +
			"MIME-Version: 1.0\r\n" +
			"Content-Type: text/html; charset=\"UTF-8\"\r\n" +
			"\r\n" +
			body.String(),
	)

	return msg, nil
}

func ServerAuthCodeSend(userEmail string) (string, error) {
	authServerCode := serverAuthCodeGenerate()
	sMTPServerAuthSubject, sMTPServerAddr := sMTPServerAuth(serverEmail)
	data := struct{ Code string }{Code: authServerCode}

	msg, err := executeTmpl(serverEmail, userEmail, authCodeSubject, data)
	if err != nil {
		return "", err
	}
	if err := mailSend(serverEmail, userEmail, sMTPServerAuthSubject, sMTPServerAddr, msg); err != nil {
		return "", err
	}

	return authServerCode, nil
}

func SuspiciousLoginEmailSend(userEmail, login, userAgent string) error {
	sMTPServerAuthSubject, sMTPServerAddr := sMTPServerAuth(serverEmail)
	data := struct {
		login     string
		userAgent string
	}{login: login, userAgent: userAgent}

	msg, err := executeTmpl(serverEmail, userEmail, suspiciousLoginSubject, data)
	if err != nil {
		return errors.WithStack(err)
	}
	if err := mailSend(serverEmail, userEmail, sMTPServerAuthSubject, sMTPServerAddr, msg); err != nil {
		return errors.WithStack(err)
	}

	return nil
}

func PasswordResetEmailSend(userEmail, resetLink string) error {
	sMTPServerAuthSubject, sMTPServerAddr := sMTPServerAuth(serverEmail)
	data := struct{ ResetLink string }{ResetLink: resetLink}

	msg, err := executeTmpl(serverEmail, userEmail, passwordResetSubject, data)
	if err != nil {
		return err
	}
	if err := mailSend(serverEmail, userEmail, sMTPServerAuthSubject, sMTPServerAddr, msg); err != nil {
		return err
	}

	return nil
}

TmplsRenderer.go
package tools

import (
	"html/template"
	"net/http"

	"github.com/pkg/errors"
)

func Must(t *template.Template, err error) *template.Template {
	return template.Must(t, err)
}

var (
	BaseTmpl = Must(template.New("base").Parse(baseTMPL))
	_        = Must(BaseTmpl.Parse(signUpTMPL))
	_        = Must(BaseTmpl.Parse(signInTMPL))
	_        = Must(BaseTmpl.Parse(homeTMPL))
	_        = Must(BaseTmpl.Parse(serverAuthCodeSendTMPL))
	_        = Must(BaseTmpl.Parse(emailMsgWithServerAuthCodeTMPL))
	_        = Must(BaseTmpl.Parse(emailMsgAboutSuspiciousLoginEmailTMPL))
	_        = Must(BaseTmpl.Parse(generatePasswordResetLinkTMPL))
	_        = Must(BaseTmpl.Parse(emailMsgWithPasswordResetLinkTMPL))
	_        = Must(BaseTmpl.Parse(setNewPasswordTMPL))
	_        = Must(BaseTmpl.Parse(setFirstTimePasswordTMPL))
	_        = Must(BaseTmpl.Parse(emailMsgAboutNewDeviceLoginEmailTMPL))
)

func TmplsRenderer(w http.ResponseWriter, tmpl *template.Template, templateName string, data interface{}) error {
	if err := tmpl.ExecuteTemplate(w, templateName, data); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

const (
	baseTMPL = `
{{ define "base" }}
<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>{{ block "title" . }}Default Title{{ end }}</title>
	<link rel="stylesheet" href="/public/styles.css">
</head>
<body>
	<div class="container">
		{{ template "content" . }}
	</div>
	{{if .ShowCaptcha}}
	<script src="https://www.google.com/recaptcha/api.js" async defer></script>
	{{end}}
</body>
</html>
{{ end }}
`
	signUpTMPL = `
{{ define "signUp" }}
<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>Sign Up</title>
	<link rel="stylesheet" href="/public/styles.css">
</head>
<body>
	<div class="container">
		<h1>Sign Up</h1>
		{{if .Msg}}<div class="error-msg">{{.Msg}}</div>{{end}}
		{{if .Regs}}
		<div class="requirements-list {{if eq .Msg "Login is invalid"}}error-highlight{{end}}">
			{{range .Regs}}
			<div>{{.}}</div>
			{{end}}
		</div>
		{{end}}
		<form method="POST" action="/validate-sign-up-input" Id="signup-form">
			<div class="form-group">
				<label for="username">Username</label>
				<input type="text" Id="username" name="login">
			</div>
			<div class="form-group">
				<label for="email">Email</label>
				<input type="email" Id="email" name="email">
			</div>
			<div class="form-group">
				<label for="password">Password</label>
				<input type="password" Id="password" name="password">
			</div>
			{{if .ShowCaptcha}}
			<div class="g-recaptcha g-recaptcha-centered" data-sitekey="6LfUPt4rAAAAAAEU_lnGN9DbW_QngiTObsj8ro0D"></div>
			{{end}}
			<button type="submit" class="btn" Id="signup-button">Sign Up</button>
		</form>
		<div class="divIder signin-gap-fix">
			<span>or</span>
		</div>
		<form method="GET" action="/yauth">
			<button type="submit" class="oauth-btn">Sign up with Yandex</button>
		</form>
		<div class="login-link">
			Already have an account? <a href="/sign-in">Sign In</a>
		</div>
	</div>
	<script>
		document.getElementById('signup-form').addEventListener('submit', function() {
			const button = document.getElementById('signup-button');
			button.disabled = true;
			button.textContent = 'Loading...';
		});
	</script>

	{{if .ShowCaptcha}}
	<script src="https://www.google.com/recaptcha/api.js" async defer></script>
	{{end}}

</body>
</html>
{{ end }}
`
	serverAuthCodeSendTMPL = `
{{ define "serverAuthCodeSend" }}
<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>Verification Code</title>
	<link rel="stylesheet" href="/public/styles.css">
</head>
<body>
	<div class="container">
		<h1>Verification</h1>
		{{if .Msg}}<div class="error-msg">{{.Msg}}</div>{{end}}
		<p class="msg">We've sent a verification code to your email. Please enter it below.</p>
		<form method="POST" action="/user-add">
			<div class="form-group">
				<label for="clientCode">Verification Code</label>
				<input type="text" Id="clientCode" name="clientCode" required maxlength="6" pattern="[0-9]*" inputmode="numeric">
			</div>
			<button type="submit" class="btn">Verify</button>
		</form>
		{{if .Msg}}
		<div class="resend">
			DIdn't receive the code?
			<form method="GET" action="/code-send">
				<button type="submit" class="btn">Send again</button>
			</form>
		</div>
		{{end}}
	</div>
</body>
</html>
{{ end }}
`
	signInTMPL = `
{{ define "signIn" }}
<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>Sign In</title>
	<link rel="stylesheet" href="/public/styles.css">
	<style>
		.error-highlight {
			color: #ff0000;
			font-weight: bold;
		}
	</style>
</head>
<body>
	<div class="container">
		<h1>Sign In</h1>
		{{if .Msg}}
			{{if eq .Msg "User does not exist"}}
			<div class="error error-highlight">
				User does not exist
			</div>
			{{else if eq .Msg "Pass the verification reCAPTCHA."}}
			<div class="error-msg">{{.Msg}}</div>
			{{else if eq .Msg "Login is invalid"}}
			<div class="error error-highlight">{{.Msg}}</div>
			{{else}}
			<div class="error">{{.Msg}}</div>
			{{end}}
		{{end}}
		{{if .NoPassword}}
			<div class="error-msg">
				You signed up using Yandex. Please sign in with Yandex and set a password in your account settings.
			</div>
		{{end}}
		{{if .Regs}}
		<div class="requirements-list">
			{{range .Regs}}
			<div>{{.}}</div>
			{{end}}
		</div>
		{{end}}
		<form method="POST" action="/sign-in-input-Validate">
			<div class="form-group">
				<label for="login">Username</label>
				<input type="text" Id="login" name="login">
			</div>
			<div class="form-group">
				<label for="password">Password</label>
				<input type="password" Id="password" name="password">
			</div>
			{{if .ShowCaptcha}}
			<div class="g-recaptcha g-recaptcha-centered" data-sitekey="6LfUPt4rAAAAAAEU_lnGN9DbW_QngiTObsj8ro0D"></div>
			{{end}}
			<button type="submit" class="btn">Sign In</button>
		</form>
		<div class="divIder">
			<span>or</span>
		</div>
		<form method="GET" action="/yauth">
			<button type="submit" class="oauth-btn">Sign in with Yandex</button>
		</form>
		{{if .ShowForgotPassword}}
		<div class="error-msg reset-hint">
			Forgot your password? <a href="/password-reset">Reset Password</a>
		</div>
		{{end}}
		<div class="login-link signin-gap-fix">
			Don't have an account? <a href="/sign-up">Sign Up</a>
		</div>
	</div>
	{{if .ShowCaptcha}}
	<script src="https://www.google.com/recaptcha/api.js" async defer></script>
	{{end}}
</body>
</html>
{{ end }}
`
	homeTMPL = `
{{ define "home" }}
<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>Home</title>
	<link rel="stylesheet" href="/public/styles.css">
</head>
<body>
	<div class="container">
		<div class="header">
			<h1>Welcome</h1>
			<div class="header-buttons">
				{{if .ShowSetPassword}}
				<form method="GET" action="/set-password">
					<button type="submit" class="btn btn-primary">Set Password</button>
				</form>
				{{end}}
				<form method="GET" action="/logout">
					<button type="submit" class="btn btn-danger">Sign Out</button>
				</form>
				<form method="GET" action="/simple-logout">
					<button type="submit" class="btn btn-primary">Logout</button>
				</form>
			</div>
		</div>
		<div class="welcome">
			<p>You have successfully signed in. You can now use all the features of the application.</p>
		</div>
	</div>
</body>
</html>
{{ end }}
`
	generatePasswordResetLinkTMPL = `
{{ define "generatePasswordResetLink" }}
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Password Reset</title>
	<link rel="stylesheet" href="/public/styles.css">
</head>
<body>
	<div class="container">
		{{if not .Msg}}
		<h1>Password Reset</h1>
		<p class="msg">Enter your email to reset your password.</p>
		<form method="POST" action="/generate-password-reset-link">
			<div class="form-group">
				<label for="email">Email</label>
				<input type="email" Id="email" name="email" required autocomplete="email">
			</div>
			<button type="submit" class="btn">Submit</button>
		</form>
		{{else}}
			{{if eq .Msg "Password reset link has been sent to your email."}}
				<div class="msg success-msg" style="text-align:center; padding: 1.5rem 0;">{{.Msg}}</div>
			{{else}}
				<div class="error-msg" style="text-align:center; padding: 1.5rem 0;">{{.Msg}}</div>
			{{end}}
		{{end}}
	</div>
</body>
</html>
{{ end }}
`
	setFirstTimePasswordTMPL = `
{{ define "setFirstTimePassword" }}
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Set Password</title>
    <link rel="stylesheet" href="/public/styles.css">
    <meta name="viewport" content="wIdth=device-wIdth, initial-scale=1" />
    </head>
<body>
    <div class="container">
        <h1>Set Account Password</h1>
        <p class="msg">Your account was created via Yandex. To enable password login, set a password below.</p>
        {{if .Msg}}<div class="error-msg">{{.Msg}}</div>{{end}}
        {{if .Regs}}
        <div class="requirements-list">
            {{range .Regs}}
            <div>{{.}}</div>
            {{end}}
        </div>
        {{end}}
        <form method="POST" action="/submit-password">
            <div class="form-group">
                <label for="password">Password</label>
                <input type="password" Id="password" name="password" required autocomplete="new-password">
            </div>
            <div class="form-group">
                <label for="confirmPassword">Confirm Password</label>
                <input type="password" Id="confirmPassword" name="confirmPassword" required autocomplete="new-password">
            </div>
            <button type="submit" class="btn">Set Password</button>
        </form>
    </div>
</body>
</html>
{{ end }}
`
	emailMsgWithServerAuthCodeTMPL = `
{{ define "emailMsgWithServerAuthCode" }}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="wIdth=device-wIdth, initial-scale=1">
    <title>Email Verification Code</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --text-color: #e5e7eb;
            --bg-color: #1f2937;
            --container-bg: #374151;
            --border-color: #4b5563;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #1f2937; /* var(--bg-color); */
            color: #e5e7eb; /* var(--text-color); */
            line-height: 1.5;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* Changed from height to min-height */
            margin: 0; /* Added */
            padding: 20px; /* Added */
        }
        .container {
            max-wIdth: 400px;
            margin: 2rem auto; /* Added for centering */
            padding: 2rem;
            background: #374151; /* var(--container-bg); */
            border-radius: 8px;
            text-align: center;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #2563eb; /* var(--primary-color); */
        }
        .code-box {
            font-size: 2rem;
            letter-spacing: 0.3em;
            background: #2563eb; /* var(--primary-color); */
            color: #fff;
            padding: 0.5em 1em;
            border-radius: 6px;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(0,0,0,0.10);
            border: 0.5px solId #1d4ed8;
            display: inline-block;
            margin: 1.5rem 0;
        }
        p {
            margin-bottom: 1.5rem;
            color: #e5e7eb; /* var(--text-color); */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Email Verification</h1>
        <p>Your verification code:</p>
        <div class="code-box">{{.Code}}</div>
        <p>Enter this code to continue.</p>
    </div>
</body>
</html>
{{ end }}
`
	emailMsgAboutSuspiciousLoginEmailTMPL = `
{{ define "emailMsgAboutSuspiciousLoginEmail" }}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="wIdth=device-wIdth, initial-scale=1">
    <title>Suspicious login attempt</title>
    <style>
        :root {
            --primary-color: #dc2626;
            --text-color: #e5e7eb;
            --bg-color: #1f2937;
            --container-bg: #374151;
            --border-color: #4b5563;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #1f2937;
            color: #e5e7eb;
            line-height: 1.5;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-wIdth: 400px;
            margin: 2rem auto;
            padding: 2rem;
            background: #374151;
            border-radius: 8px;
            text-align: center;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #dc2626; /* Red for warning */
        }
        p {
            margin-bottom: 1.5rem;
            color: #e5e7eb;
        }
        .warning-text {
            color: #fca5a5; /* Lighter red */
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
    <h1>Suspicious login attempt detected</h1>
    <p>Login attempt from: {{.userAgent}}.</p>
    <p>If unauthorized, change your password immediately.</p>
</div>
</body>
</html>
{{ end }}
`
	emailMsgWithPasswordResetLinkTMPL = `
{{ define "emailMsgWithPasswordResetLink" }}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="wIdth=device-wIdth, initial-scale=1">
    <title>Password Reset</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --text-color: #e5e7eb;
            --bg-color: #1f2937;
            --container-bg: #374151;
            --border-color: #4b5563;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.5;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        .container {
            max-wIdth: 400px;
            padding: 2rem;
            background: var(--container-bg);
            border-radius: 8px;
            text-align: center;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }
        p {
            margin-bottom: 1.5rem;
            color: var(--text-color);
        }
        .button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 1rem;
            background-color: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Password Reset</h1>
        <p>You have requested a password reset. Please click the button below to reset your password:</p>
        <p>
            <a href="{{.ResetLink}}" target="_blank" rel="noopener" role="button" style="
                display:inline-block;
                background-color:#2563eb;
                color:#ffffff;
                text-decoration:none;
                padding:10px 20px;
                border-radius:6px;
                font-weight:600;">
                Reset Password
            </a>
        </p>
        <p>If you don't see the button or it doesn't work, you can simply click this link, or copy and paste it into your browser:</p>
        <p>{{.ResetLink}}</p>
        <p>If you dId not request a password reset, please ignore this email.</p>
    </div>
</body>
</html>
{{ end }}
`
	setNewPasswordTMPL = `
{{ define "setNewPassword" }}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="wIdth=device-wIdth, initial-scale=1">
    <title>Set New Password</title>
    <link rel="stylesheet" href="/public/styles.css">
</head>
<body>
    <div class="container">
        <h1>Set New Password</h1>
        {{if .Msg}}<div class="error-msg">{{.Msg}}</div>{{end}}
        <form method="POST" action="/set-new-password">
            <div class="form-group">
                <label for="oldPassword">Old Password</label>
                <input type="password" Id="oldPassword" name="oldPassword" required autocomplete="current-password">
            </div>
            <div class="form-group">
                <label for="newPassword">New Password</label>
                <input type="password" Id="newPassword" name="newPassword" required autocomplete="new-password">
            </div>
            <div class="form-group">
                <label for="confirmPassword">Confirm New Password</label>
                <input type="password" Id="confirmPassword" name="confirmPassword" required autocomplete="new-password">
            </div>
            <input type="hIdden" name="token" value="{{.Token}}">
            <button type="submit" class="btn">Set Password</button>
        </form>
    </div>
</body>
</html>
{{ end }}
`
	emailMsgAboutNewDeviceLoginEmailTMPL = `
{{ define "emailMsgAboutNewDeviceLoginEmail" }}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="wIdth=device-wIdth, initial-scale=1">
    <title>New device login</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --text-color: #e5e7eb;
            --bg-color: #1f2937;
            --container-bg: #374151;
            --border-color: #4b5563;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #1f2937; /* var(--bg-color); */
            color: #e5e7eb; /* var(--text-color); */
            line-height: 1.5;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* Changed from height to min-height */
            margin: 0; /* Added */
            padding: 20px; /* Added */
        }
        .container {
            max-wIdth: 400px;
            margin: 2rem auto; /* Added for centering */
            padding: 2rem;
            background: #374151; /* var(--container-bg); */
            border-radius: 8px;
            text-align: center;
        }
        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #2563eb; /* var(--primary-color); */
        }
        p {
            margin-bottom: 1.5rem;
            color: #e5e7eb; /* var(--text-color); */
        }
    </style>
</head>
<body>
<div class="container">
    <h1>New device login</h1>
    <p>Detected a login from a new device</p>
    <p>If this was not you, change your password</p>
</div>
</body>
</html>
{{ end }}
`
)

tokenizer.go
package tools

import (
	"os"
	"time"

	"github.com/gimaevra94/auth/app/structs"
	"github.com/golang-jwt/jwt"
	"github.com/pkg/errors"
)

func GeneraterefreshToken(refreshTokenExp int, rememberMe bool) (string, error) {
	refreshTokenExp24Hours := 24 * 60 * 60
	if !rememberMe {
		refreshTokenExp = refreshTokenExp24Hours
	}

	refreshTokenExpiresAt := time.Now().Unix() + int64(refreshTokenExp)
	refreshTokenIssuedAt := time.Now().Unix()
	standardClaims := jwt.StandardClaims{
		ExpiresAt: refreshTokenExpiresAt,
		IssuedAt:  refreshTokenIssuedAt,
	}

	refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, standardClaims)
	jwtSecret := []byte(os.Getenv("JWT_SECRET"))
	signedrefreshToken, err := refreshToken.SignedString(jwtSecret)
	if err != nil {
		return "", errors.WithStack(err)
	}

	return signedrefreshToken, nil
}

func GeneratePasswordResetLink(email, baseURL string) (string, error) {
	passwordResetTokenExp15Minutes := time.Now().Add(15 * time.Minute)
	passwordResetTokenExp15MinutesExpiresAt := passwordResetTokenExp15Minutes.Unix()
	passwordResetTokenExp15MinutesIssuedAt := time.Now().Unix()
	passwordResetTokenClaims := structs.PasswordResetTokenClaims{
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: passwordResetTokenExp15MinutesExpiresAt,
			IssuedAt:  passwordResetTokenExp15MinutesIssuedAt,
		},
		Email: email,
	}

	resetToken := jwt.NewWithClaims(jwt.SigningMethodHS256, passwordResetTokenClaims)
	jwtSecret := []byte(os.Getenv("JWT_SECRET"))
	signedPasswordResetToken, err := resetToken.SignedString(jwtSecret)
	if err != nil {
		return "", errors.WithStack(err)
	}

	passwordResetLink := baseURL + "?token=" + signedPasswordResetToken
	return passwordResetLink, nil
}

validator.go
package tools

import (
	"net/http"
	"os"
	"regexp"

	"github.com/gimaevra94/auth/app/structs"

	"github.com/golang-jwt/jwt"
	"github.com/pkg/errors"
)

var (
	loginRegex    = regexp.MustCompile(`^[a-zA-Z--0-9]{3,30}$`)
	emailRegex    = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9]([a-zA-Z0-9.-]*[a-zA-Z0-9])?(\.[a-zA-Z]{2,})+$`)
	passwordRegex = regexp.MustCompile(`^[a-zA-Z--\d!@#$%^&*\-\)]{4,30}$`)
)

func InputValidate(r *http.Request, login, email, password string, IsSignIn bool) (string, error) {
	var errmsgKey string
	if login == "" || !loginRegex.MatchString(login) {
		err := errors.New("loginInvalid")
		errmsgKey = "loginInvalid"
		return errmsgKey, errors.WithStack(err)
	}

	if password == "" || !passwordRegex.MatchString(password) {
		err := errors.New("passwordInvalid")
		errmsgKey = "passwordInvalid"
		return errmsgKey, errors.WithStack(err)
	}

	if !IsSignIn {
		if email == "" || !emailRegex.MatchString(email) {
			err := errors.New("emailInvalid")
			errmsgKey = "emailInvalid"
			return errmsgKey, errors.WithStack(err)
		}
	}

	return errmsgKey, nil
}

func RefreshTokenValidate(refreshToken string) error {
	signedToken, err := jwt.ParseWithClaims(refreshToken, &jwt.StandardClaims{}, func(t *jwt.Token) (interface{}, error) {
		if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok || t.Method.Alg() != jwt.SigningMethodHS256.Alg() {
			err := errors.New("unexpected signing method")
			return nil, errors.WithStack(err)
		}
		jwtSecret := []byte(os.Getenv("JWT_SECRET"))
		return jwtSecret, nil
	})
	if err != nil {
		return errors.WithStack(err)
	}

	if !signedToken.Valid {
		err := errors.New("Refresh token invalid")
		return errors.WithStack(err)
	}

	return nil
}

func CodeValidate(r *http.Request, clientCode, serverCode string) error {
	if clientCode == "" {
		err := errors.New("clientCode not exist")
		return errors.WithStack(err)
	}

	if clientCode != serverCode {
		err := errors.New("codes not match")
		return errors.WithStack(err)
	}
	return nil
}

func EmailValidate(email string) error {
	if email == "" || !emailRegex.MatchString(email) {
		err := errors.New("email invalid")
		return errors.WithStack(err)
	}
	return nil
}

func PasswordValidate(password string) error {
	if password == "" || !passwordRegex.MatchString(password) {
		err := errors.New("password invalid")
		return errors.WithStack(err)
	}
	return nil
}

func ResetTokenValidate(signedToken string) (*structs.PasswordResetTokenClaims, error) {
	claims := &structs.PasswordResetTokenClaims{}

	tok, err := jwt.ParseWithClaims(signedToken, claims, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, errors.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return []byte(os.Getenv("JWT_SECRET")), nil
	})

	if err != nil {
		return nil, errors.WithStack(err)
	}

	if !tok.Valid {
		return nil, errors.New("token invalid")
	}

	return claims, nil
}

main.go
package main

import (
	"log"
	"net/http"
	"os"

	"github.com/gimaevra94/auth/app/auth"
	"github.com/gimaevra94/auth/app/consts"
	"github.com/gimaevra94/auth/app/data"
	"github.com/gimaevra94/auth/app/tmpls"
	"github.com/go-chi/chi"
	"github.com/joho/godotenv"
	"github.com/pkg/errors"
)

const (
	validateSignUpInputURL       = "/validate-sign-up-input"
	setUserInDbURL               = "/set-user-in-db"
	validateSignInInputURL       = "/validate-sign-in-input"
	generatePasswordResetLinkURL = "/generate-password-reset-link"
	yandexCallbackURL            = "/ya_callback"
	setNewPasswordURL            = "/set-new-password"
	setFirstTimePasswordURL      = "/set-first-time-password"
	logoutURL                    = "/logout"
	simpleLogoutURL              = "/simple-logout"
)

func main() {
	initEnv()
	initDb()
	data.InitStore()
	r := initRouter()
	serverStart(r)
	defer data.DbClose()
}

func initEnv() {
	if err := godotenv.Load("../public/.env"); err != nil {
		log.Printf("%+v", errors.WithStack(err))
		return
	}

	envVars := []string{
		"CAPTCHA_STORE_SESSION_SECRET_KEY",
		"LOGIN_STORE_SESSION_AUTH_KEY",
		"LOGIN_STORE_SESSION_ENCRYPTION_KEY",
		"JWT_SECRET",
		"DB_PASSWORD",
		"SERVER_EMAIL",
		"SERVER_EMAIL_PASSWORD",
		"GOOGLE_CAPTCHA_SECRET",
		"clientId",
		"clientSecret",
	}

	for _, v := range envVars {
		if os.Getenv(v) == "" {
			err := errors.New(v + " not exist")
			log.Printf("%+v", errors.WithStack(err))
			return
		}
	}
}

func initDb() {
	if err := data.DbConn(); err != nil {
		log.Printf("%+v", errors.WithStack(err))
		return
	}
}

func initRouter() *chi.Mux {
	r := chi.NewRouter()

	r.Handle("/public/*", http.StripPrefix("/public/", http.FileServer(http.Dir("../public"))))

	r.Get("/", func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, consts.SignUpURL, http.StatusFound)
	})

	r.With(auth.AuthGuardForSignInPath).Get(consts.SignUpURL, tmpls.SignUp)
	r.Post(validateSignUpInputURL, auth.ValidateSignUpInput)
	r.With(auth.AuthGuardForSignUpPath).Get(consts.CodeSendURL, tmpls.CodeSend)
	r.Post(setUserInDbURL, auth.SetUserInDb)

	r.With(auth.AuthGuardForSignInPath).Get(consts.SignInURL, tmpls.SignIn)
	r.Post(validateSignInInputURL, auth.ValidateSignInInput)

	r.Get("/yauth", auth.YandexAuthHandler)
	r.Get(yandexCallbackURL, auth.YandexCallbackHandler)

	r.Get(consts.PasswordResetURL, tmpls.PasswordReset)
	r.Post(generatePasswordResetLinkURL, auth.GeneratePasswordResetLink)
	r.With(auth.ResetTokenGuard).Get(setNewPasswordURL, tmpls.SetNewPassword)
	r.Post(setNewPasswordURL, auth.SetNewPassword)
	r.With(auth.AuthGuardForHomePath).Get(setFirstTimePasswordURL, tmpls.SetFirstTimePassword)
	r.Post(setFirstTimePasswordURL, auth.SetFirstTimePassword)

	r.With(auth.AuthGuardForHomePath).Get(consts.HomeURL, tmpls.Home)

	r.With(auth.AuthGuardForHomePath).Get(logoutURL, auth.Logout)
	r.With(auth.AuthGuardForHomePath).Get(simpleLogoutURL, auth.SimpleLogout)

	r.Get("/clear", data.ClearCookiesDev)

	r.Get(consts.Err500URL, tmpls.Err500)

	return r
}

func serverStart(r *chi.Mux) {
	if err := http.ListenAndServe(":8080", r); err != nil {
		log.Printf("%+v", errors.WithStack(err))
		return
	}
}
