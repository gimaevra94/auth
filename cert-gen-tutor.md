**Шаг 0: Подготовка (на хост-машине)**

*   **Цель:** Создать отдельную папку для хранения сертификатов и убедиться, что старый MySQL-контейнер остановлен.
*   **Команды:**
    ```bash
    mkdir -p C:\Users\gimaevra94\Documents\git\auth\certs\mysql_cert
    cd C:\Users\gimaevra94\Documents\git\auth\certs\mysql_cert
    ```
    ```bash
    docker stop <имя_или_ID_вашего_mysql_контейнера>
    ```
*   **Что происходит:**
    *   Создается новая папка `mysql_cert` внутри `certs`.
    *   Ваша командная строка переходит в эту папку.
    *   MySQL-контейнер останавливается, если он был запущен. Это важно, потому что мы будем пересоздавать его с новыми настройками.

---

**Шаг 1: Генерация самоподписанных SSL/TLS сертификатов (используя Docker-контейнер)**

*   **Цель:** Создать все необходимые файлы сертификатов (`ca-key.pem`, `ca.pem`, `server-key.pem`, `server-req.pem`, `server-cert.pem`). Мы используем временный Docker-контейнер, чтобы не устанавливать `openssl` на вашу Windows-машину.
*   **Команда:** (Убедитесь, что вы **находитесь в папке `C:\Users\gimaevra94\Documents\git\auth\certs\mysql_cert`**, как установили в Шаге 0)
    ```bash
    docker run --rm -v "$(pwd):/certs" alpine sh -c " \
      apk add --no-cache openssl && \
      openssl genrsa 2048 > /certs/ca-key.pem && \
      openssl req -new -x509 -nodes -days 3650 -key /certs/ca-key.pem -out /certs/ca.pem -subj '/CN=My MySQL CA/O=MyOrg/C=US' && \
      openssl genrsa 2048 > /certs/server-key.pem && \
      openssl req -new -key /certs/server-key.pem -out /certs/server-req.pem -subj '/CN=localhost/O=MyOrg/C=US' && \
      openssl x509 -req -in /certs/server-req.pem -days 3650 -CA /certs/ca.pem -CAkey /certs/ca-key.pem -set_serial 01 -out /certs/server-cert.pem \
    "
    ```
*   **Что происходит:**
    *   Docker запускает временный контейнер из образа `alpine`.
    *   Ваша текущая директория `C:\Users\gimaevra94\Documents\git\auth\certs\mysql_cert` монтируется внутрь контейнера как `/certs`.
    *   Внутри контейнера устанавливается `openssl` (через `apk add`).
    *   Последовательно выполняются команды `openssl`:
        *   Генерируется приватный ключ для вашего Корневого Центра Сертификации (`ca-key.pem`).
        *   Создается самоподписанный корневой сертификат (`ca.pem`).
        *   Генерируется приватный ключ для MySQL-сервера (`server-key.pem`).
        *   Создается запрос на подписание сертификата для сервера (`server-req.pem`).
        *   Этот запрос подписывается вашим корневым CA, создавая конечный сертификат сервера (`server-cert.pem`).
    *   После завершения всех операций, временный Docker-контейнер удаляется (`--rm`).
    *   **Результат:** В вашей папке `C:\Users\gimaevra94\Documents\git\auth\certs\mysql_cert` появляются 5 `.pem` файлов. `server-req.pem` можно удалить.

---

**Шаг 2: Обновление конфигурации Docker Compose**

*   **Цель:** Изменить ваш `docker-compose.yml`, чтобы MySQL-сервис знал о сертификатах и требовал SSL/TLS соединения.
*   **Действие:** Откройте файл `C:\Users\gimaevra94\Documents\git\auth\Docker\docker-compose.yml` в текстовом редакторе.
*   **Изменения в файле:** Найдите сервис `db` и добавьте/измените следующие строки:
    ```yaml
    # Docker/docker-compose.yml
    services:
      db:
        image: gimaevra94/db:latest
        # ... другие ваши настройки ...
        volumes:
          - db:/var/lib/mysql
          - C:/Users/gimaevra94/Documents/git/auth/certs/mysql_cert:/etc/mysql/certs:ro # ДОБАВЬТЕ ЭТУ СТРОКУ
        # ... другие ваши настройки ...
        command: > # ДОБАВЬТЕ ЭТОТ БЛОК
          --ssl-ca=/etc/mysql/certs/ca.pem
          --ssl-cert=/etc/mysql/certs/server-cert.pem
          --ssl-key=/etc/mysql/certs/server-key.pem
          --require_secure_transport=ON
    ```
*   **Что происходит:**
    *   Строка `volumes` создает "мост" между вашей папкой с сертификатами на хосте и `/etc/mysql/certs` внутри контейнера MySQL. `:ro` делает её только для чтения, что хорошо для безопасности.
    *   Блок `command` передает MySQL инструкции при запуске:
        *   `--ssl-ca`, `--ssl-cert`, `--ssl-key`: Указывают MySQL, где найти соответствующие файлы сертификатов внутри контейнера.
        *   `--require_secure_transport=ON`: **Это критически важная опция**. Она заставляет MySQL **отклонять любые попытки соединения, которые не используют SSL/TLS**.

---

**Шаг 3: Применение изменений Docker Compose (Пересоздание контейнеров)**

*   **Цель:** Заставить Docker Compose прочитать обновленный `docker-compose.yml` и пересоздать MySQL-контейнер с новыми SSL/TLS настройками.
*   **Предварительно:** Убедитесь, что в вашем `.env` файле (который находится в `C:\Users\gimaevra94\Documents\git\auth`) есть строка `DB_PASSWORD=ваш_надежный_пароль`.
*   **Команды:** (Убедитесь, что вы **находитесь в корневой директории вашего проекта `C:\Users\gimaevra94\Documents\git\auth`**).
    ```powershell
    cd C:\Users\gimaevra94\Documents\git\auth
    docker compose -f Docker/docker-compose.yml --profile dev down
    docker compose -f Docker/docker-compose.yml --profile dev up -d
    ```
*   **Что происходит:**
    *   `docker compose down`: Останавливает все сервисы, определенные в `docker-compose.yml` (включая ваш MySQL-контейнер `db`), и **удаляет их контейнеры**. Это необходимо, так как изменения в `volumes` и `command` применяются только при *создании* контейнера.
    *   Ваши данные MySQL, хранящиеся в именованном томе `db`, **не удаляются** этой командой. Они в безопасности.
    *   `docker compose up -d`: Читает обновленный `docker-compose.yml`. Поскольку контейнера `db` больше нет, он **создает новый контейнер** с вашими новыми настройками монтирования сертификатов и параметрами запуска SSL/TLS.
    *   Новый контейнер `db` запускается в фоновом режиме (`-d`).
    *   **Результат:** У вас запущен новый MySQL-контейнер, который сконфигурирован на использование SSL/TLS.

---

**Шаг 4: Проверка работы SSL/TLS (верификация)**

*   **Цель:** Убедиться, что MySQL действительно работает в "защищенном" режиме и требует SSL/TLS.
*   **Команды и действия:**

    1.  **Проверка статуса SSL внутри MySQL:**
        *   **Команда:**
            ```bash
            docker exec -it <имя_вашего_mysql_контейнера> mysql -uroot -p
            # Введите пароль (из вашего .env)
            ```
        *   **Внутри консоли MySQL, выполните:**
            ```sql
            SHOW STATUS LIKE 'Ssl_cipher';
            ```
        *   **Что происходит:** MySQL покажет вам текущий статус SSL. Если значение `Ssl_cipher` не пустое (например, `TLS_AES_256_GCM_SHA384`), это означает, что MySQL успешно загрузил сертификаты и готов к SSL/TLS соединениям.

    2.  **Попытка подключения БЕЗ SSL/TLS (должна закончиться ошибкой):**
        *   **Команда:**
            ```bash
            docker exec -it <имя_вашего_mysql_контейнера> mysql -uroot -p -h localhost
            # Или с вашей хост-машины (если клиент mysql установлен и порт проброшен):
            # mysql -h 127.0.0.1 -P 3306 -uroot -p
            ```
        *   **Что происходит:** Поскольку вы установили `--require_secure_transport=ON`, MySQL должен **отклонить это соединение**. Вы должны увидеть ошибку, похожую на `ERROR 3159 (HY000): Connections using insecure transport are prohibited...` или `SSL connection required`. Это подтверждает, что "защищенный" режим работает.

    3.  **Попытка подключения С SSL/TLS (должна быть успешной):**
        *   **Действие:** Запустите ваше Go-приложение.
        *   **Убедитесь, что ваш Go-код настроен правильно:**
            *   Он должен загружать `ca.pem` (с корректным путем: `C:/Users/gimaevra94/Documents/git/auth/certs/mysql_cert/ca.pem`).
            *   DSN должен содержать `?tls=custom`.
        *   **Что происходит:** Ваше Go-приложение должно успешно подключиться к MySQL и вывести сообщение типа `Успешно подключено к MySQL с TLS!`. Это подтверждает, что SSL/TLS соединение успешно установлено и работает.

---

Вот и весь алгоритм. Вы успешно прошли путь от генерации сертификатов до их использования в Docker Compose и проверки защищенного соединения!

---

Отлично, давайте подробно разберем эту мощную команду. Она объединяет все шаги по генерации SSL/TLS сертификатов для MySQL в одну, автоматизированную операцию.

```bash
docker run --rm -v "$(pwd):/certs" alpine sh -c " \
  apk add --no-cache openssl && \
  openssl genrsa 2048 > /certs/ca-key.pem && \
  openssl req -new -x509 -nodes -days 3650 -key /certs/ca-key.pem -out /certs/ca.pem -subj '/CN=My db CA/O=MyOrg/C=US' && \
  openssl genrsa 2048 > /certs/db-key.pem && \
  openssl req -new -key /certs/db-key.pem -out /certs/db-req.pem -subj '/CN=localhost/O=MyOrg/C=US' && \
  openssl x509 -req -in /certs/db-req.pem -days 3650 -CA /certs/ca.pem -CAkey /certs/ca-key.pem -set_serial 01 -out /certs/db-cert.pem \
"
```
docker run --rm -v "$(pwd):/certs" alpine sh -c " \
  apk add --no-cache openssl && \
  openssl req -new -x509 -nodes -days 3650 -key /certs/ca/ca-key.pem -out /certs/ca/ca.pem -subj '/CN=My app CA/O=MyOrg/C=US' && \
  openssl genrsa 2048 > /certs/app-key.pem && \
  openssl req -new -key /certs/app-key.pem -out /certs/app-req.pem -subj '/CN=localhost/O=MyOrg/C=US' && \
  openssl x509 -req -in /certs/app-req.pem -days 3650 -CA /certs/ca.pem -CAkey /certs/ca-key.pem -set_serial 01 -out /certs/app-cert.pem \
"

Эта команда выполняется на вашей хост-машине (Windows), но все операции по генерации сертификатов происходят внутри временного Docker-контейнера. Это позволяет избежать необходимости устанавливать `openssl` напрямую на Windows.

Давайте разберем команду по частям:

### **`docker run --rm -v "$(pwd):/certs" alpine sh -c "`**

1.  **`docker run`**:
    *   Это базовая команда Docker для запуска нового контейнера.

2.  **`--rm`**:
    *   Этот флаг указывает Docker автоматически **удалить контейнер после его завершения**. Это очень удобно для таких одноразовых задач, как генерация файлов, так как не оставляет "мусора" в вашей системе Docker.

3.  **`-v "$(pwd):/certs"`**:
    *   Это опция **монтирования тома (volume mounting)**. Она связывает директорию на вашей хост-машине с директорией внутри Docker-контейнера.
    *   **`"$(pwd)"`**: В Unix-подобных системах (и в PowerShell в Windows, если правильно сконфигурировано или используется `$((Get-Location).Path)`) это подстановка, которая возвращает **полный путь к вашей текущей рабочей директории**.
        *   **Важно:** Для этой команды вы должны находиться в директории `C:\Users\gimaevra94\Documents\git\auth\certs\mysql_cert`. Таким образом, `$(pwd)` будет раскрываться в `C:/Users/gimaevra94/Documents/git/auth/certs/mysql_cert`.
    *   **`:/certs`**: Это путь внутри Docker-контейнера, куда будет смонтирована ваша текущая директория с хоста. Все, что будет записано в `/certs` внутри контейнера, появится в вашей локальной папке `C:\Users\gimaevra94\Documents\git\auth\certs\mysql_cert`.
    *   **Суть:** Это позволяет контейнеру записывать сгенерированные сертификаты непосредственно в вашу локальную папку.

4.  **`alpine`**:
    *   Это имя Docker-образа, который будет использоваться для создания временного контейнера. `alpine` - это очень маленький и легковесный дистрибутив Linux, который идеально подходит для таких задач.

5.  **`sh -c "..."`**:
    *   Это указывает Docker запустить оболочку `sh` (Bourne Shell) внутри контейнера и выполнить команду, которая находится в кавычках `"...`.
    *   Все, что находится внутри этих двойных кавычек, является единой строкой команд, которые будут выполнены последовательно внутри `alpine` контейнера.

### **Содержимое `sh -c "..."` (цепочка команд `openssl`)**

Вся сложная часть происходит внутри этих кавычек. Каждая отдельная команда в этой цепочке разделена оператором `&&`.

*   **`&&` (логическое И):**
    *   Этот оператор означает "и если предыдущая команда завершилась успешно". Он гарантирует, что следующая команда будет выполнена только в том случае, если предыдущая команда выполнилась без ошибок. Это критично для надежности процесса.

1.  **`apk add --no-cache openssl`**:
    *   **`apk`**: Это менеджер пакетов для Alpine Linux.
    *   **`add`**: Команда для установки пакетов.
    *   **`--no-cache`**: Опция, которая указывает `apk` не сохранять кэш пакетов после установки. Это помогает сохранить размер контейнера минимальным.
    *   **`openssl`**: Имя пакета, который мы устанавливаем. Этот пакет предоставляет утилиту командной строки `openssl`, необходимую для генерации сертификатов.
    *   **Что происходит:** Утилита `openssl` устанавливается во временный контейнер.

2.  **`openssl genrsa 2048 > /certs/ca-key.pem`**:
    *   **`openssl genrsa`**: Команда `openssl` для генерации RSA приватного ключа.
    *   **`2048`**: Указывает длину ключа в битах (2048 бит — стандартный безопасный размер).
    *   **`>`**: Перенаправляет вывод команды в файл.
    *   **`/certs/ca-key.pem`**: Путь к файлу внутри контейнера, куда будет сохранен сгенерированный приватный ключ CA. Благодаря монтированию тома, этот файл появится в вашей локальной папке `C:\Users\gimaevra94\Documents\git\auth\certs\mysql_cert`.
    *   **Что происходит:** Генерируется приватный ключ для вашего корневого центра сертификации (CA). Этот ключ будет использоваться для подписи других сертификатов.

3.  **`openssl req -new -x509 -nodes -days 3650 -key /certs/ca-key.pem -out /certs/ca.pem -subj '/CN=My MySQL Root CA/O=MyOrg/C=US'`**:
    *   **`openssl req`**: Команда `openssl` для работы с запросами на сертификаты (CSR) и самоподписанными сертификатами.
    *   **`-new`**: Указывает на создание нового запроса (в данном случае, для самоподписанного сертификата).
    *   **`-x509`**: Этот флаг указывает, что мы хотим создать **самоподписанный сертификат**, а не просто запрос на него (CSR). Именно так создается корневой CA сертификат.
    *   **`-nodes`**: "no DES" – не шифровать приватный ключ. Это упрощает использование ключа, но делает его менее безопасным, если он попадет в чужие руки. Для внутренних тестовых целей это обычно приемлемо.
    *   **`-days 3650`**: Устанавливает срок действия сертификата в 3650 дней (примерно 10 лет).
    *   **`-key /certs/ca-key.pem`**: Указывает путь к приватному ключу, который будет использоваться для подписи этого сертификата (в данном случае, это наш только что сгенерированный приватный ключ CA).
    *   **`-out /certs/ca.pem`**: Путь к выходному файлу, где будет сохранен сгенерированный CA сертификат.
    *   **`-subj '/CN=My MySQL Root CA/O=MyOrg/C=US'`**: **Ключевой флаг для автоматизации!** Он позволяет передать информацию о владельце сертификата (Subject Name) напрямую, без интерактивного запроса.
        *   `CN`: Common Name (Общее имя). Это наиболее важная часть для идентификации. Для корневого CA это может быть что угодно, например, "My MySQL Root CA".
        *   `O`: Organization (Организация).
        *   `C`: Country (Страна).
        Вы можете изменить `MyOrg` и `US` на свои данные.
    *   **Что происходит:** Создается сам CA сертификат, который является корнем доверия для всех других сертификатов, которые вы подпишете с его помощью.

4.  **`openssl genrsa 2048 > /certs/server-key.pem`**:
    *   Аналогично генерации `ca-key.pem`, эта команда создает приватный ключ, но уже для самого MySQL-сервера.
    *   **Что происходит:** Генерируется приватный ключ для MySQL-сервера.

5.  **`openssl req -new -key /certs/server-key.pem -out /certs/server-req.pem -subj '/CN=localhost/O=MyOrg/C=US'`**:
    *   **`openssl req -new`**: Создает новый запрос на подписание сертификата (Certificate Signing Request, CSR).
    *   **`-key /certs/server-key.pem`**: Указывает, какой приватный ключ использовать для этого запроса.
    *   **`-out /certs/server-req.pem`**: Путь к выходному файлу CSR.
    *   **`-subj '/CN=localhost/O=MyOrg/C=US'`**: Снова флаг для неинтерактивного ввода Subject Name.
        *   **`CN=localhost`**: **Это ОЧЕНЬ ВАЖНО!** Common Name для серверного сертификата **должен точно совпадать** с тем именем хоста или IP-ададресом, по которому клиентское приложение будет подключаться к MySQL.
            *   Если вы подключаетесь с хоста по `127.0.0.1` или `localhost`, то `CN=localhost` (или `CN=127.0.0.1`) подходит.
            *   Если ваше Go-приложение находится в другом Docker-контейнере и подключается к MySQL по имени сервиса (например, `db`), то `CN` должен быть `db`.
            *   Если подключение идет по публичному IP, то `CN` должен быть этим IP.
    *   **Что происходит:** Создается запрос, который будет передан нашему CA для подписи, чтобы получить конечный сертификат сервера.

6.  **`openssl x509 -req -in /certs/server-req.pem -days 3650 -CA /certs/ca.pem -CAkey /certs/ca-key.pem -set_serial 01 -out /certs/server-cert.pem`**:
    *   **`openssl x509`**: Утилита для работы с X.509 сертификатами (стандарт для SSL/TLS).
    *   **`-req`**: Указывает, что входной файл (`-in`) является запросом на сертификат (CSR).
    *   **`-in /certs/server-req.pem`**: Путь к входному файлу CSR, который мы только что сгенерировали.
    *   **`-days 3650`**: Срок действия сгенерированного серверного сертификата.
    *   **`-CA /certs/ca.pem`**: Указывает, какой CA сертификат использовать для подписи.
    *   **`-CAkey /certs/ca-key.pem`**: Указывает приватный ключ CA, который будет использоваться для подписи.
    *   **`-set_serial 01`**: Устанавливает серийный номер для нового сертификата. Это необходимо, так как CA может выдавать несколько сертификатов.
    *   **`-out /certs/server-cert.pem`**: Путь к выходному файлу, где будет сохранен подписанный сертификат сервера MySQL.
    *   **Что происходит:** Наш корневой CA (который мы создали ранее) подписывает запрос на сертификат для MySQL-сервера. Результатом является конечный SSL/TLS сертификат (`server-cert.pem`), который MySQL будет использовать для шифрования трафика.

---

### **Конечный результат выполнения этой команды:**

После успешного выполнения этой одной длинной команды, в вашей локальной папке `C:\Users\gimaevra94\Documents\git\auth\certs\mysql_cert` появятся следующие файлы:

*   `ca-key.pem`: Приватный ключ вашего корневого CA.
*   `ca.pem`: Сертификат вашего корневого CA.
*   `server-key.pem`: Приватный ключ сервера MySQL.
*   `server-req.pem`: Запрос на подписание сертификата сервера (этот файл больше не нужен и может быть удален).
*   `server-cert.pem`: Сертификат сервера MySQL, подписанный вашим CA.

Эти файлы затем используются в `docker-compose.yml` для настройки MySQL.
